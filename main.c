// Comp:  gcc -Wall -g zeromq_1.c -lzmq -o zeromq_1

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/reg.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <assert.h>
#include <time.h>
#include <string.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>


int main() {
    printf("here\n");
    const unsigned int PACKET_SIZE = 128;
    char message[1024];
    char server_reply[1024];
    int buffer[1024];

    int sock;
    sock = socket(AF_INET , SOCK_STREAM , 0);

    struct sockaddr_in server_address;
    server_address.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(5555);

    int connected = connect(sock, (struct sockaddr*) &server_address, sizeof(server_address));
    if(connected == -1) {
        printf("Connection failed.\n");
    } else {
	printf("Connected Client\n");
    }

    char mal_buffer[PACKET_SIZE];

    // Process ID for the child process
    pid_t pid;
    pid = fork();

    // If there was a fork error, then exit
    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        exit(-1);

        // if the process is a child, then request to be traced by the parent
        // Then call then run the file to be inspected
    } else if (pid == 0) {
        // Child requests to be traced
        printf("The child process with PID: %d has run \n", (int) getpid());
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);

        
        // This is where the file to be tested should be run
        // Execute command should be used here to execute the file
        // An example is execl or execlp

        // else it is a parent process
    } else {
        // Checks if the child has exited
        int status;

        // Stores the values of the system call registers
        struct user_regs_struct regs;

        // // An int to check if the system call sequence is a malware,
        // // a boolean could be used instead of int
        // int isMal = 0;


        // The while loop runs until the child file is finished
        while (1) {
	          // FILE *f;
            // f = fopen("data", "wb");
            // // Checks if the child exited
            wait(&status);
            if (WIFEXITED(status)) {
                break;
            }

            FILE *theFile = ("data.txt","r");
            int checkNum;
            fscanf(theFile, "%d", &checkNum);
            fclose(theFile);
            if (checkNum == 0){
              FILE *theFile = ("data.txt","w");
              int reachedTen = 0;
              while(waitpid(pid, &status, 0) && ! WIFEXITED(status) && (reachedTen < 10)){
              ptrace(PTRACE_GETREGS, pid, NULL, &regs);
              fprintf(file,regs.orig_eax);
              fprintf(file," ");
              ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
              reachedTen++;
              }
              fclose(theFile);
            } else if (checkNum == 1){
                printf("Malware detected.");
                kill(pid, SIGTERM);
                break;
            }

            wait(&status);
            if (WIFEXITED(status)) {
                break;
            }
            
            // // here is to send the data to the python code and determine
            // // if the data is a mal-ware then the following if statement will terminate
            // for (int i = 0; i < 3; i++) {
            //     buffer[i] = i; //sysCalls.data[i];
            // }

	          // // Write array to file
            // fwrite(buffer, sizeof(int), 3, f);
            // fclose(f);

            // send(sock, &buffer, sizeof(buffer), 0);
            // printf("Request Recieved\r\n");
            // recv(sock, &mal_buffer, sizeof(mal_buffer), 0);
            // printf("Responded with %s\r\n", mal_buffer);

            
	          // printf("Mal buff 0: %d\n", mal_buffer[0]);


            // // if a malware sequence is detected, then kill the child and exit the loop
            // if (mal_buffer[0] == 1) {
            //     printf("Malware detected.");
            //     kill(pid, SIGTERM);
            //     break;
            //     // else, get the next system call and place it in slot 2, and
            //     // move the previous system calls into slot 0 and slot 1
            // } else {
            //     sysCalls.data[0] = sysCalls.data[1];
            //     sysCalls.data[1] = sysCalls.data[2];
            //     ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
            //     ptrace(PTRACE_GETREGS, pid, NULL, &regs);
            //     sysCalls.data[2] = regs.orig_eax;
            // }
        }
        return 0;
    }
}