// Comp:  gcc -Wall -g zeromq_1.c -lzmq -o zeromq_1

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/reg.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <assert.h>
#include <time.h>
#include <string.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>


// This is a struct that is used to store three system calls to be sent to
// the python code
typedef struct {
    int data[3];                 // item data
} item;

int main() {
    const unsigned int PACKET_SIZE = 128;
    char message[1024];
    char server_reply[1024];'
    int buffer[];
    buffer = malloc(3*sizeof(int))
    long orig_eax;

    int sock;
    sock = socket(AF_INET , SOCK_STREAM , 0);

    struct sockaddr_in server_address;
    server_address.sin_addr.s_addr = inet_addr("127.0.0.1");;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(5555);

    int connected = connect(sock, (struct sockaddr*) &server_address, sizeof(server_address));
    if(connected == -1) {
        printf("Connection failed.\n");
    }


//    void *context = zmq_ctx_new();
//    void *responder = zmq_socket(context, ZMQ_REP);
//    int rc = zmq_bind(responder, "tcp://*:5555");
//    assert (rc == 0);
    char mal_buffer[PACKET_SIZE] = {0};

    // Process ID for the child process
    pid_t pid;
    pid = fork();

    // If there was a fork error, then exit
    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        exit(-1);

        // if the process is a child, then request to be traced by the parent
        // Then call then run the file to be inspected
    } else if (pid == 0) {
        printf("The child process with PID: %d has run \n", (int) getpid());
        // This is where the file to be tested should be run
        // Execute command should be used here to execute the file
        // An example is execl or execlp

        // else it is a parent process
    } else {
        // Checks if the child has exited
        int status;

        // Stores the values of the system call registers
        struct user_regs_struct regs;

        // An int to check if the system call sequence is a malware,
        // a boolean could be used instead of int
        int isMal = 0;

        // The array item that will be sent to the python code
        item sysCalls;

        // Extracting the first three system calls from file
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[0] = regs.orig_eax;
        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[1] = regs.orig_eax;
        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[2] = regs.orig_eax;

        // The while loop runs until the child file is finished
        while (1) {

            // Checks if the child exited
            wait(&status);
            if (WIFEXITED(status)) {
                break;
            }

            // here is to send the data to the python code and determine
            // if the data is a mal-ware then the following if statement will terminate
            for (int i = 0; i < 3; i++) {
                buffer[i] = sysCalls.data[i];
            }

            send(sock, &buffer, sizeof(buffer), 0);
            printf("Request Recieved\r\n");
            recv(sock, &mal_buffer, sizeof(mal_buffer), 0);
            printf("Responded with %s\r\n", mal_buffer);

            // if a malware sequence is detected, then kill the child and exit the loop
            if (mal_buffer == "1") {
                printf("Malware detected.");
                kill(pid, SIGTERM);
                break;
                // else, get the next system call and place it in slot 2, and
                // move the previous system calls into slot 0 and slot 1
            } else {
                sysCalls.data[0] = sysCalls.data[1];
                sysCalls.data[1] = sysCalls.data[2];
                ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
                ptrace(PTRACE_GETREGS, pid, NULL, &regs);
                sysCalls.data[2] = regs.orig_eax;
            }
        }
        return 0;
    }
}