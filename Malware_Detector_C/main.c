// Comp:  gcc -Wall -g zeromq_1.c -lzmq -o zeromq_1

#include <zmq.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <linux/user.h>
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <assert.h>
#include <time.h>

// This is a struct that is used to store three system calls to be sent to
// the python code
typedef struct {
    int data[3];                 // item data
} item;

int main() {

    void *context = zmq_ctx_new();
    void *responder = zmq_socket(context, ZMQ_PUB);
    int rc = zmq_bind(responder, "tcp://*:5555");
    assert(rc == 0);
    char temp_buffer[128];

    // Process ID for the child process
    pid_t pid;
    pid = fork();

    // If there was a fork error, then exit
    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        exit(-1);

        // if the process is a child, then request to be traced by the parent
        // Then call then run the file to be inspected
    } else if (pid == 0) {
        printf("The child process with PID: %d has run \n", (int) getpid());
        // This is where the file to be tested should be run
        // Execute command should be used here to execute the file
        // An example is execl or execlp

        // else it is a parent process
    } else {
        // Checks if the child has exited
        int status;

        // Stores the values of the system call registers
        struct user_regs_struct regs;

        // An int to check if the system call sequence is a malware,
        // a boolean could be used instead of int
        int isMal = 0;

        // The array item that will be sent to the python code
        item sysCalls;

        // Extracting the first three system calls from file
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[0] = regs.orig_eax;
        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[1] = regs.orig_eax;
        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);
        sysCalls.data[2] = regs.orig_eax;

        // The while loop runs until the child file is finished
        while (1) {

            // Checks if the child exited
            wait(&status);
            if (WIFEXITED(status))
                break;

            // here is to send the data to the python code and determine
            // if the data is a mal-ware then the following if statement will terminate
            for (int i = 0; i < 3; i++) {
                buffer[i] = item.data[i];
            }
            zmq_recv (responder, buffer, 10, 0);
            printf ("Request Recieved\r\n");
            zmq_send (responder, temp_buffer, 16, 0);
            printf ("Responded with %s\r\n", temp_buffer);
            isMal = temp_buffer[0];
            // if a malware sequence is detected, then kill the child and exit the loop
            if (isMal) {
                kill(pid, SIGTERM);
                break;

                // else, get the next system call and place it in slot 2, and
                // move the previous system calls into slot 0 and slot 1
            } else {
                sysCalls.data[0] = sysCalls.data[1];
                sysCalls.data[1] = sysCalls.data[2];
                ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
                ptrace(PTRACE_GETREGS, pid, NULL, &regs);
                sysCalls.data[2] = regs.orig_eax;

            }


        }
        return 0;
    }
}